<!DOCTYPE html>
<canvas width="960" height="600"></canvas>
<label for='naturalEarth'>Natural Earth</label><input type='radio' name='mapType' id='naturalEarth' />
<label for='orthographic'>Orthographic</label><input type='radio' name='mapType' id='orthographic' />
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="https://unpkg.com/topojson-client@2"></script>
<script src="https://unpkg.com/versor@0.1.2/dist/versor.min.js"></script>
<script>

var proj_pos = 0;

var canvas = d3.select("canvas"),
    width = canvas.property("width"),
    height = canvas.property("height"),
    context = canvas.node().getContext("2d");

var projection = d3.geoOrthographic()
    .scale((height - 10) / 2)
    .translate([width / 2, height / 2])
    .precision(0.1);

var path = d3.geoPath()
    .projection(projection)
    .context(context);
	
var t = d3.timer(function() {});
	
var selectedProjection = 0;

d3.selectAll('input[name=mapType]')
	.on('change', function(){tweenProjections(this.id);});

function tweenProjections(projectionID) {
	selectedProjection = projectionID == "orthographic" ? 1 : 0;
	proj_pos = selectedProjection;
	projectionMorph();
	t.restart(function(elapsed) {
		proj_pos = (elapsed/500)
		proj_pos = proj_pos > 1 ? 1 : proj_pos
		proj_pos = selectedProjection == 0 ? 1 - proj_pos : proj_pos;
		projectionMorph();
		if (elapsed > 500) t.stop()
	}, 0)
}

canvas.call(d3.drag()
    .on("start", dragstarted)
    .on("drag", dragged));

var render = function() {},
    v0, // Mouse position in Cartesian coordinates at start of drag gesture.
    r0, // Projection rotation as Euler angles at start.
    q0; // Projection rotation as versor at start.

function dragstarted() {
  v0 = versor.cartesian(projection.invert(d3.mouse(this)));
  r0 = projection.rotate();
  q0 = versor(r0);
}

function dragged() {
  var v1 = versor.cartesian(projection.rotate(r0).invert(d3.mouse(this))),
      q1 = versor.multiply(q0, versor.delta(v0, v1)),
      r1 = versor.rotation(q1);
  projection.rotate(r1);
  render();
projectionMorph();

}

d3.json("https://unpkg.com/world-atlas@1/world/110m.json", function(error, world) {
  if (error) throw error;

  var sphere = {type: "Sphere"},
      land = topojson.feature(world, world.objects.land);

  render = function() {
    context.clearRect(0, 0, width, height);
    context.beginPath(), path(sphere), context.fillStyle = "#fff", context.fill();
    context.beginPath(), path(land), context.fillStyle = "#000", context.fill();
    context.beginPath(), path(sphere), context.stroke();
  };

  render();
});

function projectionMorph() {
	var t = proj_pos;

	var projections = [d3.geoNaturalEarth(), d3.geoOrthographic()];

	canvas.selectAll("path")
		.attr("d", getProjection)
	
	
	function getProjection(d) {
		var projection = d3.geoProjection(project)
			.rotate([posX, posY])
			.fitExtent([[10, 10], [width - 10, height - 10]], {
				type: "Sphere"
			});

		var path = d3.geoPath(projection);

		function project(λ, φ) {
		  λ *= 180 / Math.PI, 
		  φ *= 180 / Math.PI;

		  var p0 = projections[0]([λ, φ]), 
			  p1 = projections[1]([λ, φ]);

		  return [
			(1 - t) * p0[0] + t * p1[0], 
			(1 - t) * -p0[1] + t * -p1[1]
			];
		}

		return path(d)
	}

}
</script>