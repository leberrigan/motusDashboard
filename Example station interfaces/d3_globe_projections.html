
<!DOCTYPE html>
<meta charset="utf-8">

<style>


.stroke {
  fill: none;
  stroke: #000;
  stroke-width: 1px;
}
.graticule {
  fill: none;
  stroke: #777;
  stroke-width: .5px;
  stroke-opacity: .5;
}
.fill {
  fill: none;
}
.land {
  fill: #222;
}
/*.land:hover {
  fill: #F22;
}*/
.sphere {
	fill: #AAF;
}
.boundary {
  fill: #FFF;
  stroke: #fff;
  stroke-width: .5px;
}
.track {
	stroke-width: 0.5px;
	opacity: 0.5;
	cursor: pointer;
}
</style>

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="https://d3js.org/topojson.v2.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<!-- Create an element where the map will take place -->
<svg id="my_dataviz" width="900" height="600"></svg>

<label for='naturalEarth'>Natural Earth</label><input type='radio' name='mapType' id='naturalEarth' checked='checked' />
<label for='orthographic'>Orthographic</label><input type='radio' name='mapType' id='orthographic' />
<input type='button' value='Reset' id='resetMap' />
<script>
// 
// D3 Globe projections: https://github.com/d3/d3-geo
//		Orthographic: 
// 
// Tween between projections: https://bl.ocks.org/git-ashish/35d6480d477d22a21961e641955ba03c
//
// Transition between any two projections: https://bl.ocks.org/alexmacy/082cb12c8f4d5c0d5c4445c16a3db383
//
// Great circle paths: https://www.d3-graph-gallery.com/graph/connectionmap_csv.html
//
// Flight path edge bundling: https://bl.ocks.org/sjengle/2e58e83685f6d854aa40c7bc546aeb24
//
// Voronoi Arc Map: https://bl.ocks.org/mbostock/7608400
//
// Zoomable choropleth: https://observablehq.com/@bjnsn/zoomable-choropleth

// The svg
var svg = d3.select("svg").call(d3.drag().on("drag", dragged)),
    width = +svg.attr("width"),
    height = +svg.attr("height");
	
var t = d3.timer(function() {});
var resetTimer = d3.timer(function() {});
	
var selectedProjection = 0;

d3.selectAll('input[name=mapType]')
	.on('change', function(){tweenProjections(this.id);});

function tweenProjections(projectionID) {
	selectedProjection = projectionID == "orthographic" ? 1 : 0;
	centerX = selectedProjection === 0 ? 0 : 36;
	centerY = selectedProjection === 0 ? 0 : -15;
	proj_pos = selectedProjection;
	projectionMorph();
	t.restart(function(elapsed) {
		proj_pos = (elapsed/500)
		proj_pos = proj_pos > 1 ? 1 : proj_pos
		proj_pos = selectedProjection == 0 ? 1 - proj_pos : proj_pos;
		projectionMorph();
		if (elapsed > 500) t.stop();
	}, 0)
}

var posX = 0, posY = 0;

// Map and projection
var projection = d3.geoOrthographic()
    .scale(100)
	.clipAngle(90);

// A path generator
var path = d3.geoPath()
    .projection(projection)

var proj_pos = 0;

const grid = svg.append("path");

grid.datum(d3.geoGraticule().step([10, 10]))
	.attr("class", "graticule")
	.attr("d", path)
	.style("stroke", "#ccc");
		
    

		

// Load world shape AND list of connection
d3.queue()
 // .defer(d3.json, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson")  // World shape
  .defer(d3.json, "https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_50m_admin_0_countries.geojson")  // World shape
//  .defer(d3.csv, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/data_connectionmap.csv") // Position of circles
  .defer(d3.csv, "./data/siteTrans1.csv") // Position of circles
  .await(ready);

var centerX = 36,
	centerY = -15;
	
var zoom;

var zoomLevel = 1;

var colorScale;

d3.select('#resetMap').on('click', resetCenter);

function resetCenter() {
	svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
	resetTimer.restart(function(elapsed) {
		//elapsed = Math.max(0, (1000 - elapsed));
		posX = ((Math.min(1000, elapsed) / 1000) * centerX) + (posX * (Math.max(0, (1000 - elapsed)) / 1000));
		posY = ((Math.min(1000, elapsed) / 1000) * centerY) + (posY * (Math.max(0, (1000 - elapsed)) / 1000));
		//posY = () posY * (Math.max(0, (1000 - elapsed)) / 1000);
		projectionMorph();
		if (posX == centerX && posY == centerY) resetTimer.stop();
	});
}

function ready(error, dataGeo, data) {
	
	colorScale = d3.scaleOrdinal(d3.schemePaired);
			  
	var defs = svg.append("defs")

	defs.append("path")
		.datum({type: "Sphere"})
		.attr("id", "sphere")
		
	svg.append("use")
		.attr("class", "stroke")
		.attr("xlink:href", "#sphere");

	svg.append("use")
		.attr("class", "fill")
		.attr("xlink:href", "#sphere");

	proj_pos = d3.select('input[name=mapType]:checked').attr('id') == 'orthographic' ? 1 : 0;
	
    // Reformat the list of link. Note that columns in csv file are called long1, long2, lat1, lat2
    var link = [];
	
	data.forEach(function(row){
		source = [+row.lon1, +row.lat1]
		target = [+row.lon2, +row.lat2]
		topush = {type: "LineString", coordinates: [source, target], id: row.tagDeployID}
		link.push(topush)
	});
	
	// Draw the map
    const land = svg.append("g");
	
	land.selectAll("path")
        .data(dataGeo.features)
        .enter().append("path")
			.attr("class", "land")
            .attr("d", d3.geoPath()
                .projection(projection)
            )
            .style("stroke", "#FFF")
            .style("stroke-width", 0);
		
    // Add the path
    const tracks = svg.selectAll("myPath");
	
    tracks.data(link)
		.enter()
		.append("path")
		.attr("class", "track")
		.attr("d", (d) => path(d))
		.attr('class', (d) => "track track" + d.id)
		.style("fill", "none")
		.style('stroke', (d) => colorScale(d.id))
		.on('mouseover', function(d){d3.selectAll(".track" + d.id).style('opacity', '1');d3.selectAll(".track:not(.track" + d.id + ")").style('opacity', '0.1');})
		.on('mouseout', function(d){d3.selectAll(".track").style('opacity', '0.5');});
		
	zoom = d3.zoom()
		.scaleExtent([1, 10])
		.translateExtent([[0, 0], [900, 600]])
		.extent([[0, 0], [900, 600]])
		.on("zoom", function() {
			svg.selectAll('path')
				.attr("transform", d3.event.transform);
		})
		.on('end', function() {
			zoomLevel = d3.event.transform.k;
		});
	
	svg.call(zoom);
	
	projectionMorph();
	resetCenter();

}

function dragged() {
  posX = ( posX + d3.event.dx / (4 * zoomLevel) ) % 360;
  posY = ( posY - d3.event.dy / (4 * zoomLevel) ) % 360;
  projectionMorph();
}

function projectionMorph() {
	var t = proj_pos;
	var projections = [d3.geoNaturalEarth(), d3.geoOrthographic()];
	
	  
	centerX = selectedProjection == 0 ? 0 : 36;
	centerY = selectedProjection == 0 ? 0 : -15;
  
	svg.selectAll("path")
	  .attr("d", getProjection)
	  
	function getProjection(d) {
		var projection = d3.geoProjection(project)
			.rotate([posX, posY])
		   // .rotate([posX + 36, posY - 15])
			.fitExtent([[10, 10], [width - 10, height - 10]], {
			  type: "Sphere"
			});

		var path = d3.geoPath(projection);

		var clip = projection.clipAngle;

		clip( t == 0 ? null : (180 - (t * 90)) )

		function project(λ, φ) {
		  λ *= 180 / Math.PI, 
		  φ *= 180 / Math.PI;

		  var p0 = projections[0]([λ, φ]), 
			  p1 = projections[1]([λ, φ]);

		  return [
			(1 - t) * p0[0] + t * p1[0], 
			(1 - t) * -p0[1] + t * -p1[1]
			];
		}
		projection.alpha = function(_) {
			if (!arguments.length) return α;
			α = +_;
			var ca = a.center(), cb = b.center(),
			ta = a.translate(), tb = b.translate();
			center([(1 - α) * ca[0] + α * cb[0], (1 - α) * ca[1] + α * cb[1]]);
			translate([(1 - α) * ta[0] + α * tb[0], (1 - α) * ta[1] + α * tb[1]]);
			if (ortho === true) {clip(180 - α * 90);}
			return projection;
		};

		return path(d)
	}

}
</script>